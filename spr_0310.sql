-- 크로스 조인 (데카르트 곱, 카테시안 곱)
SELECT *
FROM EMP, DEPT;

-- 내부 조인 (별칭 적용)
SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO -- 표 이름.열 이름
ORDER BY EMPNO, DNAME;

-- 
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY DEPTNO, EMPNO;

SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, E.DEPTNO, DNAME, LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY DEPTNO, EMPNO;

--220P 1분 복습
SELECT E.EMPNO, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

--223P 1분 복습
SELECT EMPNO, ENAME, SAL, D.DEPTNO, DNAME, LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND SAL<=2500 AND EMPNO<=9999
ORDER BY EMPNO;

-- 비등가 조인
SELECT *
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

-- 자체 조인
SELECT E1.EMPNO, E1.ENAME, E1.JOB, E1.MGR, E2.EMPNO AS 관리자_번호, E2.ENAME AS 관리자_이름
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

-- 외부 조인 (제외된 NULL값도 추가 표기)
SELECT E1.EMPNO, E1.ENAME, E1.JOB, E1.MGR, E2.EMPNO AS 관리자_번호, E2.ENAME AS 관리자_이름
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+) -- 왼쪽 MGR(부하직원)를 기준으로 동일한 오른쪽 EMPNO를 출력
ORDER BY E1.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.JOB, E1.MGR, E2.EMPNO AS 관리자_번호, E2.ENAME AS 관리자_이름
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO -- 오른쪽 EMPNO(관리자)를 기준으로 동일한 왼쪽 MGR을 출력
ORDER BY E1.EMPNO;

-- SQL-99 표준 문법
-- NATURAL JOIN !조인 대상이 되는 테이블에 이름과 자료형이 같은 열을 기준으로 등가 조인
SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME, LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, EMPNO;

-- JOIN ~ USING [조인에 사용할 기준열] (=등가 조인)
SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME, LOC
FROM EMP E JOIN DEPT D USING (DEPTNO)
WHERE SAL >= 2500
ORDER BY DEPTNO, EMPNO;

-- JOIN ~ ON [조인에 사용할 조건식]
SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, E.DEPTNO, DNAME, LOC
FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
WHERE SAL >= 2500
ORDER BY DEPTNO, EMPNO;

-- OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.JOB, E1.MGR, E2.EMPNO AS 관리자_번호, E2.ENAME AS 관리자_이름
FROM EMP E1 LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;

--- 3개의 테이블을 조인
-- ORACLE 조인
SELECT E1.EMPNO AS 사원번호, E1.ENAME AS 사원명, E1.JOB AS 담당,
E1.DEPTNO AS 부서번호, DNAME AS 부서, E1.MGR AS 관리자,
E2.EMPNO AS 관리자_번호, E2.ENAME AS 관리자_이름
FROM EMP E1, EMP E2, DEPT D
WHERE E1.MGR = E2.EMPNO(+)
AND E1.DEPTNO = D.DEPTNO
ORDER BY E1.EMPNO;
-- 표준문법 조인
SELECT E1.EMPNO AS 사원번호, E1.ENAME AS 사원명, E1.JOB AS 담당,
E1.DEPTNO AS 부서번호, DNAME AS 부서, E1.MGR AS 관리자,
E2.EMPNO AS 관리자_번호, E2.ENAME AS 관리자_이름
FROM EMP E1 JOIN EMP E2 ON (E1.MGR = E2.EMPNO) JOIN DEPT D ON (E1.DEPTNO = D.DEPTNO)
ORDER BY E1.EMPNO;

--- SUBQUERY
-- 사원JONES보다 급여가 높은 사원을 출력하라.
--- 서브쿼리를 사용하지 않은 경우
SELECT SAL
FROM EMP
WHERE ENAME = 'JONES';
-- 로 JONES의 급여를 조회
SELECT *
FROM EMP
WHERE SAL > 2975;
-- JONES의 급여 '2975'보다 높은 급여를 조회

--- 서브쿼리 사용
SELECT *
FROM EMP
WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME='JONES');
-- 서브쿼리 'JONES'의 급여를 조회하고 메인쿼리로 급여보다 높은 급여를 조회

--245P 1분 복습
SELECT *
FROM EMP
WHERE COMM > (SELECT COMM FROM EMP WHERE ENAME='ALLEN');

-- 단일행 서브쿼리
SELECT * FROM EMP
WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME='JONES');

-- 조인과 서브쿼리
SELECT EMPNO, ENAME, JOB, SAL, E.DEPTNO, DNAME, LOC
FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO AND E.DEPTNO=20)
WHERE SAL > (SELECT AVG(SAL) FROM EMP);

-- 다중행 서브쿼리
SELECT * FROM EMP WHERE DEPTNO IN (20, 30);

-- 각 부서별 최고 급여와 동일한 급여를 받는 사원정보 출력하기
SELECT EMPNO, ENAME, DEPTNO, SAL
FROM EMP
WHERE SAL IN (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

-- 30번 부서 사원들의 최대 급여보다 적은 급여를 받는 사원 정보 출력
SELECT ENAME, SAL, DEPTNO FROM EMP
WHERE SAL < (SELECT MAX(SAL) FROM EMP WHERE DEPTNO=30);
SELECT ENAME, SAL, DEPTNO FROM EMP
WHERE SAL > ANY (SELECT SAL FROM EMP WHERE DEPTNO=30);

-- 다중열 서브쿼리
SELECT * FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL)
                            FROM EMP GROUP BY DEPTNO);

--- FROM절과 SELECT절의 서브쿼리
--FROM절 서브쿼리
SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, E10.DEPTNO, DNAME, LOC
FROM (SELECT * FROM EMP WHERE DEPTNO=10) E10 JOIN (SELECT * FROM DEPT) D ON (E10.DEPTNO = D.DEPTNO);

SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, E10.DEPTNO, DNAME, LOC
FROM (SELECT * FROM EMP WHERE DEPTNO=10) E10, (SELECT * FROM DEPT) D
WHERE E10.DEPTNO = D.DEPTNO;

-- WITH절
WITH
E10 AS (SELECT * FROM EMP WHERE DEPTNO=10),
D AS (SELECT * FROM DEPT)
SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, E10.DEPTNO, DNAME, LOC
FROM E10, D
WHERE E10.DEPTNO = D.DEPTNO;

--SELECT절 서브쿼리
SELECT EMPNO, ENAME, SAL,
(SELECT GRADE FROM SALGRADE WHERE E.SAL BETWEEN LOSAL AND HISAL) AS SALGRADE, DEPTNO,
(SELECT DNAME FROM DEPT WHERE E.DEPTNO=DEPT.DEPTNO) AS DNAME
FROM EMP E
ORDER BY DNAME, DEPTNO;

CREATE TABLE EMP_TEMP AS SELECT * FROM EMP;

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE = 1;

DELETE FROM EMP_TEMP
WHERE EMPNO IN (SELECT E.EMPNO FROM EMP_TEMP E, SALGRADE S WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE=3 AND DEPTNO=30);

ROLLBACK;

SELECT * FROM EMP_TEMP;